1.1 С помощью Event loop задачи попадают в call stack. Т.к. JS однопоточный язык программирования, то код выполняются поочередно. 
Сначала вызванное событие попадает в очередь(Callback queue), дальше в call stack и если это синхронный код, то оно сразу выполняется. 
В браузере асинхронные события, например, setTimeOut или запрос на сервер обрабатываются с помощью Web Apis. Обработчики событий, хоть это и синхронный код, но тоже хранятся в Web Apis, до момента его срабатывания. 
Далее, в случае с setTimeOut, проходит заданное количество времени,после которого код внутри него выполняется и помещается в очередь, откуда попадает в стек вызова и выполняется.
В случае обработчика события, например, клика на кнопку, код также попадает в очередь и потом, когда до него дойдет очередь, попадает в стек вызова и выполняется. 

1.2. Main Thread - это основной поток. Так как js однопоточный язык программирования, поэтому все задачи выполняются в основном потоке, например рендериг страницы, обработка событий.

1.3. Сначала формируется DOM 
     Затем CSSOM
     Дальше формируется дерево рендеринга, как DOM, только без невидимых элементов. Это визуальное представление дом. 
     После этого рассчитывается положение на странице для каждого элемента.
     Идет отрисовка страницы в браузере. 


2. (этот ответ продублирован в файле Task2.js)
Начинает выполняться промис. 
Promise выполняется асинхронно, поэтому сразу выполнится return 7.
Затем будет выполняться Promise. 
В нем мы видим асинхронную функцию setTimeout без аргумента задежки, значит по умолчанию там стоит 0. 
Но все равно он будет вызван после выполнения текущего кода. Насколько я помню, js вместо 0 подставляет там 4ms. 
Далее промис успешно выполнится и в консоль будет выведено число 1.
После этого сработает ошибка и вернет 5.
Далее then c console.log(2) не будет выполнен и отработает блок кода catch((er)=>console.log(er)), где в консоль будет выведено число 5.
Т.к. catch возвращает Promise, то следующий за ним then будет выполнен и в консоль выведется значение 4.
finally выполняется как после catch, так и после then, поэтому дальше в консоль будет вывеведено число 6.
После этого выполнится отложенный setTimeout и в консоль выведется число 0.

3.
  const array = [3,6,1,2,5,2,9,3];

  function sortArray(arr){
      let doubleArray = [];

      let newArray = arr
          .sort((a,b) => a-b)
          .filter((item, index) => {
              if(arr.indexOf(item) !== index)
                  doubleArray.push(item);
              else 
                  return item
      });

      return [...newArray, ...doubleArray];
  }

  console.log(sortArray());
